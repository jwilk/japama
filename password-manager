#!/usr/bin/python3

import argparse
import math
import os
import random
import subprocess as ipc
import sys
import textwrap

import yaml

def main():
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers()
    c_show = subparsers.add_parser('show',
        help='show (some) passwords',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description=textwrap.dedent(do_show.__doc__),
    )
    c_show.add_argument('--omit', action='store_true', help='omit passwords')
    c_show.add_argument('--pick', metavar='N[,N...]', help='pick only some characters')
    c_show.add_argument('-x', '--x-clipboard', action='store_true', help='copy the password to clipboard')
    c_show.add_argument('keyword', metavar='KEYWORD')
    c_show.set_defaults(action=do_show)
    c_generate = subparsers.add_parser('generate', help='generate passwords')
    c_generate.add_argument('--length', default=10, type=int, help='password length')
    c_generate.add_argument('count', nargs='?', type=int, help='number of passwords to generate')
    c_generate.set_defaults(action=do_generate)
    options = parser.parse_args()
    return options.action(options)

def fatal(message):
    prog = os.path.basename(sys.argv[0])
    print(
        '{prog}: error: {msg}'.format(prog=prog, msg=message),
        file=sys.stderr
    )
    sys.exit(1)

def parse_pick(s):
    if s is None:
        return str
    lst = []
    for item in s.split(','):
        if '-' in item:
            l, r = (int(x, 10) for x in item.split('-', 1))
        else:
            l = r = int(item, 10)
        if l < 1:
            raise IndexError('index should be a positive integer: {idx}'.format(idx=l))
        if l > r:
            raise IndexError('empty range: {l} > {r}'.format(l=l, r=r))
        lst += range(l - 1, r)
    return lambda p: ''.join(p[i] for i in lst)

def do_show(options):
    '''
    Read password file from standard input and output (some) passwords.
    The password file should be GPG-encrypted YAML file using the following
    structure:

       - site: http://bogus.example.net/
         user: j.r.hacker
         password: PnlUbPkPtq

       - site: http://random.example.org/
         user: jrh
         password: cUUZ4oUXFv

    '''
    try:
        pick_filter = parse_pick(options.pick)
    except (IndexError, ValueError) as exc:
        fatal('cannot parse --pick argument: {exc}'.format(exc=exc))
    gpg = ipc.Popen(['gpg', '-q', '-d'], stdout=ipc.PIPE)
    lines = yaml.load(gpg.stdout)
    for item in lines or []:
        site = str(item['site'])
        if not options.keyword in site:
            continue
        password = str(item['password'])
        password = pick_filter(password)
        if '#' in password:
            continue
        user = str(item.get('user', '<none>'))
        xclip = None
        if options.omit:
            password = '<omitted>'
        elif options.x_clipboard:
            options.x_clipboard = False
            options.omit = True
            xclip = ipc.Popen(['xclip', '-l', '1', '-verbose'],
                stdin=ipc.PIPE,
                stderr=open(os.devnull, 'w')
            )
            xclip.stdin.write(password.encode('ASCII'))
            xclip.stdin.close()
            password = '<in-x-clipboard>'
        print('{site} ({user}) {password}'.format(
            site=site, user=user, password=password)
        )
        if xclip is not None:
            if xclip.wait() != 0:
                fatal('xclip failed')
    if gpg.wait() != 0:
        fatal('gpg failed')

def char_range(a, b):
    return [chr(n) for n in range(ord(a), ord(b))]

def do_generate(options):
    if options.count is None:
        options.count = 1
    alphabet = (
        char_range('a', 'z') +
        char_range('A', 'Z') +
        char_range('0', '9')
    )
    chunk_bits = math.log(len(alphabet), 2) * options.length
    chunk_bits = int(math.ceil(chunk_bits))
    sysrandom = random.SystemRandom()
    for i in range(options.count):
        while True:
            bigint = sysrandom.getrandbits(chunk_bits)
            if bigint < len(alphabet) ** options.length:
                break
        password = [None] * options.length
        for j in range(options.length):
            bigint, password[j] = divmod(bigint, len(alphabet))
        assert bigint == 0
        password = ''.join(alphabet[ch] for ch in password)
        print(password)

if __name__ == '__main__':
    main()

# vim:ts=4 sw=4 et
