#!/usr/bin/python3

import argparse
import math
import os
import subprocess as ipc
import sys
import textwrap

import yaml

def main():
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers()
    c_show = subparsers.add_parser('show',
        help='show (some) passwords',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description=textwrap.dedent(do_show.__doc__),
    )
    c_show.add_argument('--omit', action='store_true', help='omit passwords')
    c_show.add_argument('-x', '--x-clipboard', action='store_true', help='copy the password to clipboard')
    c_show.add_argument('keyword', metavar='KEYWORD')
    c_show.set_defaults(action=do_show)
    c_generate = subparsers.add_parser('generate', help='generate passwords')
    c_generate.add_argument('--length', default=10, type=int, help='password length')
    c_generate.add_argument('count', nargs='?', type=int, help='number of passwords to generate')
    c_generate.set_defaults(action=do_generate)
    options = parser.parse_args()
    return options.action(options)

def do_show(options):
    '''
    Read password file from standard input and output (some) passwords.
    The password file should be GPG-encrypted YAML file using the following
    structure:

       - site: http://bogus.example.net/
         user: j.r.hacker
         password: PnlUbPkPtq

       - site: http://random.example.org/
         user: jrh
         password: cUUZ4oUXFv

    '''
    gpg = ipc.Popen(['gpg', '-q', '-d'], stdout=ipc.PIPE)
    lines = yaml.load(gpg.stdout)
    for item in lines or []:
        site = str(item['site'])
        if not options.keyword in site:
            continue
        password = str(item['password'])
        if '#' in password:
            continue
        user = str(item.get('user', '<none>'))
        xclip = None
        if options.omit:
            password = '<omitted>'
        elif options.x_clipboard:
            options.x_clipboard = False
            options.omit = True
            xclip = ipc.Popen(['xclip', '-l', '1', '-verbose'],
                stdin=ipc.PIPE,
                stderr=open(os.devnull, 'w')
            )
            xclip.stdin.write(password.encode('ASCII'))
            xclip.stdin.close()
            password = '<in-x-clipboard>'
        print('{site} ({user}) {password}'.format(
            site=site, user=user, password=password)
        )
        if xclip is not None:
            if xclip.wait() != 0:
                raise IOError('xclip failed')
    if gpg.wait() != 0:
        raise IOError('gpg failed')

def char_range(a, b):
    return [chr(n) for n in range(ord(a), ord(b))]

def do_generate(options):
    if options.count is None:
        options.count = 1
    alphabet = (
        char_range('a', 'z') +
        char_range('A', 'Z') +
        char_range('0', '9')
    )
    chunk_bits = math.log(len(alphabet), 2) * options.length
    chunk_bytes = int(math.ceil(chunk_bits / 8))
    chunk_bits = int(math.ceil(chunk_bits))
    gpg = ipc.Popen(['gpg', '--gen-random', '1'], stdout=ipc.PIPE)
    try:
        for i in range(options.count):
            while True:
                blob = gpg.stdout.read(chunk_bytes)
                bigint = 0
                for byte in blob:
                    bigint <<= 8
                    bigint |= byte
                bigint &= (1 << chunk_bits) - 1
                if bigint >= len(alphabet) ** options.length:
                    continue
                password = [None] * options.length
                for j in range(options.length):
                    bigint, password[j] = divmod(bigint, len(alphabet))
                assert bigint == 0
                password = ''.join(alphabet[ch] for ch in password)
                print(password)
                break
    finally:
        # Ugh, .stdout.close() is not enough and .terminate() would generate an
        # ugly error message.
        gpg.kill()
        gpg.wait()

if __name__ == '__main__':
    main()

# vim:ts=4 sw=4 et
